if (min(qqkeep$age_from > 0 || max(qqkeep$age_to) < 90) == FALSE) {
# Chloe edit 3/22/19: Removing this line so as to not lump all 30+ groups together and replacing with next one.
# qqkeep$ageband<-ifelse(qqkeep$age_from < 30, paste0("Age_", qqkeep$age_from, "_",qqkeep$age_to), "Age_30")
qqkeep$ageband<-paste0("Age_", qqkeep$age_from, "_",qqkeep$age_to)
bands<-qqkeep%>%group_by(country_code, ageband)%>%summarize(tot=sum(value),minage=min(age_from))
totpop<-qqkeep%>%group_by(country_code)%>%summarize(totpop=sum(value))
if (totpop[,2] > 0) {
numsall<-merge(x=bands, y=totpop, by="country_code")
numsall$fraction<-numsall$tot/numsall$totpop
agedist <- numsall[order(numsall$minage),]
dist<-agedist$fraction
names(dist)<-agedist$ageband
return(dist)
} else {
disterr<<-"Population value is zero.  Please check qqpop file."
return(FALSE)
}
} else {
disterr<<-"Incomplete age bands for this country and year"
return(FALSE)
}
} else {
disterr<<-"No age distribution input found for this country and year"
return(FALSE)
}
GetPopAgeDist(path, mycountry, start)
bands
totpop
dist
#parameters for initializing
mypop<-GetPopAgeDist(path=inputdir, mycountry=country, start=start)
mypop
GetPopAgeDist(path, mycountry, start)
GetPopAgeDist<-function(path, mycountry, start) {
disterr<<-""
setwd(path)
qqfile<-GetFilename(path, "qq_pop_both")
if (is.character(qqfile)==FALSE) { stop(mymsg) }
qqdf<-read.csv(qqfile)
if (CheckDemogFileStructure(mycountry=mycountry, mydf=qqdf, dfdesc="qq_pop_both")==FALSE) { stop (filemsg)}
#record for every 5th year - want the closest to start or before start?
mround <- function(x,base){
base*round(x/base)
}
popyr<-mround(year(start), 5)
qqkeep<-qqdf[qqdf$country_code==mycountry & qqdf$year==popyr,]
if (nrow(qqkeep) > 0) {
if (!(DemogNumVarExists("age_from", qqkeep) & DemogNumVarExists("age_to", qqkeep))) {
disterr<<- "Non-numeric data in age band variables"
return(FALSE)
}
if (!(DemogNumVarExists("age_to", qqkeep))) { return(FALSE) }
#check min and max age band - now they all go up to 120 but lets be generous and say 90
if (min(qqkeep$age_from > 0 || max(qqkeep$age_to) < 90) == FALSE) {
# Chloe edit 3/22/19: Removing this line so as to not lump all 30+ groups together and replacing with next one.
# qqkeep$ageband<-ifelse(qqkeep$age_from < 30, paste0("Age_", qqkeep$age_from, "_",qqkeep$age_to), "Age_30")
qqkeep$ageband<-paste0("Age_", qqkeep$age_from, "_",qqkeep$age_to)
bands<-qqkeep%>%group_by(country_code, ageband)%>%summarize(tot=sum(value),minage=min(age_from))
totpop<-qqkeep%>%group_by(country_code)%>%summarize(totpop=sum(value))
if (totpop[,2] > 0) {
numsall<-merge(x=bands, y=totpop, by="country_code")
numsall$fraction<-numsall$tot/numsall$totpop
agedist <- numsall[order(numsall$minage),]
dist<-agedist$fraction
names(dist)<-agedist$ageband
return(dist)
} else {
disterr<<-"Population value is zero.  Please check qqpop file."
return(FALSE)
}
} else {
disterr<<-"Incomplete age bands for this country and year"
return(FALSE)
}
} else {
disterr<<-"No age distribution input found for this country and year"
return(FALSE)
}
}
GetPopAgeDist(path, mycountry, start)
#parameters for initializing
mypop<-GetPopAgeDist(path=inputdir, mycountry=country, start=start)
mypop
length(mypop)
##get age-specific proportions of each disease state into vectors: 7 ages X 7 disease states
## Chloe 3/22/19: now, we have 21 ages and 7 disease states.
statefract<-GetDiseaseStateDist(directory=scriptdir, region=myregion)
scriptdir <- script.dir
##get age-specific proportions of each disease state into vectors: 7 ages X 7 disease states
## Chloe 3/22/19: now, we have 21 ages and 7 disease states.
statefract<-GetDiseaseStateDist(directory=scriptdir, region=myregion)
statefract
length(statefract)
initmsg<<-""
#create the matrix
dur<- ceiling(difftime(end, start, units = "weeks"))
# poparray <- array(data=0, dim=c(361, 9, dur+1)) # Dimensions are [age groups, states, time]
# Chloe edit 3/22/19: allow for monthly ages through age 70.
poparray <- array(data=0, dim=c(841, 9, dur+1)) # Dimensions are [age groups, states, time]
dimnames(poparray)[[2]] <- c("Ns","Nc","Ls","Lc","Hs","Hc","Di","Va", "Inc")
#parameters for initializing
mypop<-GetPopAgeDist(path=inputdir, mycountry=country, start=start)
mypop
361/12
360/12
120*12
# poparray <- array(data=0, dim=c(361, 9, dur+1)) # Dimensions are [age groups, states, time]
# Chloe edit 3/22/19: allow for monthly ages through age 120, including age=0 months.
# Later on, for sake of comparison with Montagu estimates, will only look through age 70.
# Note this could make code extremely (and unecessarily) slow...maybe just through age 70 if that's the case?
poparray <- array(data=0, dim=c(1441, 9, dur+1)) # Dimensions are [age groups, states, time]
dimnames(poparray)[[2]] <- c("Ns","Nc","Ls","Lc","Hs","Hc","Di","Va", "Inc")
#parameters for initializing
mypop<-GetPopAgeDist(path=inputdir, mycountry=country, start=start)
if (length(mypop) < 7) {
initmsg<<-"Incomplete age distribution information.  Please check the downloaded file [touchstone]_qq_pop_both.csv."
return(FALSE)
}
scriptdir
directory <- scriptdir
region <- "ETH"
setwd(directory)
dxfile<-GetFilename(directory, "dist_both.csv")
if (is.character(dxfile)==FALSE) {
stop(mymsg)
print("File [dist_both.csv] is packaged with the R scripts and should be in the same directory.")
}
dist<-read.csv(dxfile, stringsAsFactors = TRUE)
dim(dist)
dist
myregion
region <- myregion
setwd(directory)
dxfile<-GetFilename(directory, "dist_both.csv")
if (is.character(dxfile)==FALSE) {
stop(mymsg)
print("File [dist_both.csv] is packaged with the R scripts and should be in the same directory.")
}
dist<-read.csv(dxfile, stringsAsFactors = TRUE)
distcol<-ifelse(region=='hyper', 4, 3)
#expand age group fraction as vector to match pop matrix dimension 1
# Chloe edit 3/22/19: changing this to match new dims; see note above.
agefract <- c(rep(as.numeric(mypop[1:6]), each=60), as.numeric(mypop[7]))
mypop
length(mypop)
#expand age group fraction as vector to match pop matrix dimension 1
# Chloe edit 3/22/19: changing this to match new dims; see note above.
# agefract <- c(rep(as.numeric(mypop[1:6]), each=60), as.numeric(mypop[7]))
# Chloe 3/29: In new age bands, all are 5-year except for last, which is 120 years.
agefract <- c(rep(as.numeric(mypop[1:20]), each=60), rep(as.numeric(mypop[21]), each=12*20))
length(agefract)
#expand age group fraction as vector to match pop matrix dimension 1
# Chloe edit 3/22/19: changing this to match new dims; see note above.
# agefract <- c(rep(as.numeric(mypop[1:6]), each=60), as.numeric(mypop[7]))
# Chloe 3/29: In new age bands, all are 5-year except for last, which is 120 years.
agefract <- c(rep(as.numeric(mypop[1:20]), each=60), rep(as.numeric(mypop[21]), each=(12*20)+1))
length(agefract)
mypop
20*60
# chunks <- c(rep(60, each=360), 1)
chunks <- c(rep(60, each=1200), rep((12*20)+1,each=(12*20)+1))
#expand age group fraction as vector to match pop matrix dimension 1
# Chloe edit 3/22/19: changing this to match new dims; see note above.
# agefract <- c(rep(as.numeric(mypop[1:6]), each=60), as.numeric(mypop[7]))
# Chloe 3/29: In new age bands, all are 5-year except for last, which is 120 years.
agefract <- c(rep(as.numeric(mypop[1:20]), each=60), rep(as.numeric(mypop[21]), each=(12*20)+1))
length(agefract)
length(chunks)
length(statefract)
mypop
statefract
# Chloe edit 3/29: repeating last 7 values for each older age group.
addition <- rep(statefract[43:49],14)
statefract <- c(statefract,addition)
length(statefract)/length(mypop)
##get age-specific proportions of each disease state into vectors: 7 ages X 7 disease states
## Chloe 3/22/19: now, we have 21 ages and 7 disease states.
## The line below gets fraction of each disease state in each of 7 population groups (5-year age bands up to age 30).
## To avoid having too many edits in too many functions, I decided to leave the "GetDiseaseStateDist" function alone, and as before,
# assume fractions in each disease state in the 30-year age band match those in the older age bands, i.e. can just repeat the
# final 7 values as needed here to provide proportion estimates up to age 120...so, if limiting to age 70 above, will need to edit this.
statefract<-GetDiseaseStateDist(directory=scriptdir, region=myregion)
statefract
matrix(rep(statefract[1:7], each=60), nrow=60)
matrix(rep(statefract[1:7], each=3), nrow=3)
statemx<-rbind(
matrix(rep(statefract[1:7], each=60), nrow=60),
matrix(rep(statefract[8:14], each=60), nrow=60),
matrix(rep(statefract[15:21], each=60), nrow=60),
matrix(rep(statefract[22:28], each=60), nrow=60),
matrix(rep(statefract[29:35], each=60), nrow=60),
matrix(rep(statefract[36:42], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=(12*20)+1), nrow=(12*20)+1)
)
dim(poparray)
poparray[,,1]
poparray[, "Ns", 1]<-(startSize*agefract/chunks)*statemx[,1]
poparray[, "Nc", 1]<-(startSize*agefract/chunks)*statemx[,2]
poparray[, "Ls", 1]<-(startSize*agefract/chunks)*statemx[,3]
poparray[, "Lc", 1]<-(startSize*agefract/chunks)*statemx[,4]
poparray[, "Hs", 1]<-(startSize*agefract/chunks)*statemx[,5]
poparray[, "Hc", 1]<-(startSize*agefract/chunks)*statemx[,6]
poparray[, "Di", 1]<-(startSize*agefract/chunks)*statemx[,7]
InitializePopulation<-function(scriptdir, inputdir, start, end, popsize, country="ETH", region="not_hyper") {
initmsg<<-""
#create the matrix
dur<- ceiling(difftime(end, start, units = "weeks"))
# poparray <- array(data=0, dim=c(361, 9, dur+1)) # Dimensions are [age groups, states, time]
# Chloe edit 3/22/19: allow for monthly ages through age 120, including age=0 months.
# Later on, for sake of comparison with Montagu estimates, will only look through age 70.
# Note this could make code extremely (and unecessarily) slow...maybe just through age 70 if that's the case?
poparray <- array(data=0, dim=c(1441, 9, dur+1)) # Dimensions are [age groups, states, time]
dimnames(poparray)[[2]] <- c("Ns","Nc","Ls","Lc","Hs","Hc","Di","Va", "Inc")
#parameters for initializing
mypop<-GetPopAgeDist(path=inputdir, mycountry=country, start=start)
# Chloe edit 3/22/19: Now, this should start with pop size of age bands between 0-4 and 100-120.
# Chloe edit 3/29/10: The error message below was originally intended for 7 age bands;
# I'm leaving this unedited for now, since I'm not sure what final groups of age bands we will use.
if (length(mypop) < 7) {
initmsg<<-"Incomplete age distribution information.  Please check the downloaded file [touchstone]_qq_pop_both.csv."
return(FALSE)
}
##get age-specific proportions of each disease state into vectors: 7 ages X 7 disease states
## Chloe 3/22/19: now, we have 21 ages and 7 disease states.
## The line below gets fraction of each disease state in each of 7 population groups (5-year age bands up to age 30).
## To avoid having too many edits in too many functions, I decided to leave the "GetDiseaseStateDist" function alone, and as before,
# assume fractions in each disease state in the 30-year age band match those in the older age bands, i.e. can just repeat the
# final 7 values as needed here to provide proportion estimates up to age 120...so, if limiting to age 70 above, will need to edit this.
statefract<-GetDiseaseStateDist(directory=scriptdir, region=myregion)
if (length(statefract) < 49) {
initmsg<<-"Incomplete disease state distribution information.  Please check the file dist_both.csv provided with the scripts."
return(FALSE)
}
#expand age group fraction as vector to match pop matrix dimension 1
# Chloe edit 3/22/19: changing this to match new dims; see note above.
# agefract <- c(rep(as.numeric(mypop[1:6]), each=60), as.numeric(mypop[7]))
# Chloe 3/29: In new age bands, all are 5-year except for last, which is 120 years.
agefract <- c(rep(as.numeric(mypop[1:20]), each=60), rep(as.numeric(mypop[21]), each=(12*20)+1))
# chunks <- c(rep(60, each=360), 1)
# Chloe: Looks as though the starting assumption is that population age bands are evenly divided
# among each included age.
chunks <- c(rep(60, each=1200), rep((12*20)+1,each=(12*20)+1))
# Exanding this to more age brackets.
# statemx<-rbind(
#  matrix(rep(statefract[1:7], each=60), nrow=60),
#  matrix(rep(statefract[8:14], each=60), nrow=60),
#  matrix(rep(statefract[15:21], each=60), nrow=60),
#  matrix(rep(statefract[22:28], each=60), nrow=60),
#  matrix(rep(statefract[29:35], each=60), nrow=60),
#  matrix(rep(statefract[36:42], each=60), nrow=60),
#  matrix(rep(statefract[43:49], each=1), nrow=1)
# )
# Assuming last 7 values of statefract (originally just for 30-34 age band) apply to all older ages (which was effectively
# implied before).
# Separate matrix for each age chunk,
# separate column for disease state, separate row for each month of age.
statemx<-rbind(
matrix(rep(statefract[1:7], each=60), nrow=60),
matrix(rep(statefract[8:14], each=60), nrow=60),
matrix(rep(statefract[15:21], each=60), nrow=60),
matrix(rep(statefract[22:28], each=60), nrow=60),
matrix(rep(statefract[29:35], each=60), nrow=60),
matrix(rep(statefract[36:42], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=60), nrow=60),
matrix(rep(statefract[43:49], each=(12*20)+1), nrow=(12*20)+1)
)
#initialize - 3rd dimension stays at 1
poparray[, "Ns", 1]<-(startSize*agefract/chunks)*statemx[,1]
poparray[, "Nc", 1]<-(startSize*agefract/chunks)*statemx[,2]
poparray[, "Ls", 1]<-(startSize*agefract/chunks)*statemx[,3]
poparray[, "Lc", 1]<-(startSize*agefract/chunks)*statemx[,4]
poparray[, "Hs", 1]<-(startSize*agefract/chunks)*statemx[,5]
poparray[, "Hc", 1]<-(startSize*agefract/chunks)*statemx[,6]
poparray[, "Di", 1]<-(startSize*agefract/chunks)*statemx[,7]
#leave Vacc, Inc 0
return(poparray)
}
library(lubridate)
library(dplyr)
library(data.table) #melt
# Chloe 2/5/19: Added package to use data.table
library(reshape2)
##parameters to set:
begin<-Sys.time()
mycountry <- "ETH"
start <- as.Date("2000-01-01")
end <- as.Date("2100-12-31")
## NOTE MANY FUNCTIONS APPEAR TO DEPEND ON THESE BEING FIRST AND LAST DATES: EDIT LATER.
myregion <- "hyper"  #"hyper" or "not_hyper"
PSA <- FALSE
vacc_program <- "none" ## "campaign" or "routine" or "both" or "none"
phi<-0.2
sd<-4567 #seed for random sto, use same for all scenarios
nSims<-10  #100 takes ~ 3 mon, 1000 takes 45
#directory containing inputs from https://montagu.vaccineimpact.org/
inputdir<-"G:/CTRHS/Modeling_Infections/GAVI MenA predictions/Data/GAVI inputs/201810synthetic_downloaded_2019"
outputdir<-"C:/Users/krakcx1/Desktop/Sim_output"
#directory containing R scripts
script.dir <- "C:/Users/krakcx1/Desktop/Cloned_meningitis_code"
###end parameters to set
#script directory contains functions
#ha, need to check script.dir so we can source parameter-checking script
if (dir.exists(script.dir)) {
if (file.exists(paste0(script.dir, "/","MenA_paramCheck.R"))==FALSE) {
msg<(paste0("MenA_paramcheck.R not found in ", script.dir))
stop(msg)
}
} else {
script.dir<- getSrcDirectory(function(dummy) {dummy})
if (file.exists(paste0(script.dir, "/","MenA_paramCheck.R"))==FALSE) {
print(paste0("MenA_paramCheck.R not found in ", script.dir))
stop("This script requires 6 other scripts; please put in same directory as this one or specify script directory.")
}
}
setwd(script.dir)
source("MenA_paramCheck.R")
source("ModelInputUtilities.R")
source("MenA_OneSim.R")
source("MenA_helper_functions.R")
source("MenA_summarization_functions.R")
#check parameters set above
setparams<-as.list(c(mycountry, as.character(start), as.character(end), myregion, PSA, vacc_program, phi, sd, nSims, inputdir, outputdir))
names(setparams)<-c("mycountry", "start", "end", "myregion", "PSA", "vacc_program", "phi", "sd", "nSims", "inputdir", "outputdir")
if (CheckSetParameters(setparams)==FALSE) {
stop(spmessage)
} else {
if (length(spmessage)>1) { print(spmessage) }
}
#country-specific parameters
myparams<-GetDemographicParameters(path=inputdir,  mycountry=mycountry, start=start, end=end)
if (CheckDemogParameters(myparams)==FALSE) {
stop(dpmessage)
} else {
if (length(dpmessage)>1) { print(dpmessage) }
}
if (vacc_program!="none") {
myvacc<-GetVaccScenario(mycountry=mycountry, scenario=vacc_program, directory=inputdir)
if (is.data.frame(myvacc)==FALSE) { stop(vaccmsg)}  #check for output
#make as vector of years where nothing happens (empty except for campaign only) for efficiency
if (vacc_program=="campaign") {
nodoses<-as.vector(myvacc[is.na(myvacc$DosesCampaign) | myvacc$DosesCampaign==0,"year"])
}
}
#fixed parameters
#uSE SAME SEED FOR ALL SCENARIOS (for setting up stochastic parameter)
set.seed(sd, kind = NULL, normal.kind = NULL)
paramfixed<-c(0.23334,0.70002,0.25,0.90,0.75,1.00,0.00000096)
names(paramfixed)<-c("rc","rd","lc","ld","hc","hd","foii")
#disease model for rainy and dry
dxrisk<-rbind(c(0.0018, -0.00000021),
c(0.0019, -0.0000002))
dimnames(dxrisk)[[1]]<-c("rainy", "dry")
#WAIFW matrix setup
wboth<-GetWAIFWmatrix(path=script.dir, region=myregion)
if (!(is.numeric(wboth))) {
stop(waifwerr)
}
#initialize population
startSize <- myparams[myparams$year==year(start)-1, "totalpop"]
initpop<-InitializePopulation(scriptdir=script.dir, inputdir=inputdir, start=start, end=end, popsize=startSize, country=mycountry, region=myregion)
dim(initpop)
if (!(is.numeric(initpop))) {
if (disterr!="") { print(disterr) }
if (dxerr!="") { print(dxerr) }
stop(initmsg)
}
startdt=start
enddt=end
pop=initpop
fixedparams=paramfixed
countryparams=myparams
WAIFWmx=wboth
dxr=dxrisk
vacc_program=vacc_program
dim(WAIFWmx)
WAIFWmx[,,1]
head(WAIFWmx[,,1])
dxrisk
dim(initpop)
dim(fixedparams)
fixedparams
countryparams
head(countryparams)
script.dir
7*12
120/12
60+96+84
240/12
1440/12
1441-240
setwd(path)
waifwfile<-GetFilename(path, "WAIFW_both.csv")
if (is.character(waifwfile)==FALSE) {
stop(mymsg)
print("File [waifw_both.csv] is packaged with the R scripts and should be in the same directory.")
}
path
path=script.dir
setwd(path)
waifwfile<-GetFilename(path, "WAIFW_both.csv")
if (is.character(waifwfile)==FALSE) {
stop(mymsg)
print("File [waifw_both.csv] is packaged with the R scripts and should be in the same directory.")
}
waifwin<-read.csv(waifwfile, stringsAsFactors = FALSE)  #vector
Rwaifw<-waifwin[waifwin$region==region & waifwin$season=='rainy', 4]
Dwaifw<-waifwin[waifwin$region==region & waifwin$season=='dry', 4]
test <- expandWaifw(waifw=Rwaifw)
dim(test)
expandWaifw<-function(waifw){
# repeat what was originally columns :
#b[x,1] 60x; b[x,2] 96x; b[1,3] 84x; b[1,4] 120x
#needs to go to 361 - add extra line at end for last big bucket
# Chloe edit 3/29: see note above.
#rbind (
# matrix(data=waifw[c(1,5,9,13)], nrow=60, ncol=4, byrow=TRUE),
#matrix(data=waifw[c(2,6,10,14)], nrow=96, ncol=4, byrow=TRUE),
#matrix(data=waifw[c(3,7,11,15)], nrow=84, ncol=4, byrow=TRUE),
#matrix(data=waifw[c(4,8,12,16)], nrow=121, ncol=4, byrow=TRUE)
#)
rbind (
matrix(data=waifw[c(1,5,9,13)], nrow=60, ncol=4, byrow=TRUE),
matrix(data=waifw[c(2,6,10,14)], nrow=96, ncol=4, byrow=TRUE),
matrix(data=waifw[c(3,7,11,15)], nrow=84, ncol=4, byrow=TRUE),
matrix(data=waifw[c(4,8,12,16)], nrow=1201, ncol=4, byrow=TRUE)
)
}
test <- expandWaifw(waifw=Rwaifw)
dim(test)
# wboth<-array(c(expandWaifw(waifw=Rwaifw), expandWaifw(waifw=Dwaifw)), dim=c(361,4,2))
# Chloe edit 3/29: Need to change dims to suit larger matrix.
wboth<-array(c(expandWaifw(waifw=Rwaifw), expandWaifw(waifw=Dwaifw)), dim=c(1441,4,2))
dimnames(wboth)[[3]]<-c("rainy", "dry")
expandWaifw<-function(waifw){
# repeat what was originally columns :
#b[x,1] 60x; b[x,2] 96x; b[1,3] 84x; b[1,4] 120x
#needs to go to 361 - add extra line at end for last big bucket
# Chloe edit 3/29: see note above.
#rbind (
# matrix(data=waifw[c(1,5,9,13)], nrow=60, ncol=4, byrow=TRUE),
#matrix(data=waifw[c(2,6,10,14)], nrow=96, ncol=4, byrow=TRUE),
#matrix(data=waifw[c(3,7,11,15)], nrow=84, ncol=4, byrow=TRUE),
#matrix(data=waifw[c(4,8,12,16)], nrow=121, ncol=4, byrow=TRUE)
#)
rbind (
matrix(data=waifw[c(1,5,9,13)], nrow=60, ncol=4, byrow=TRUE),
matrix(data=waifw[c(2,6,10,14)], nrow=96, ncol=4, byrow=TRUE),
matrix(data=waifw[c(3,7,11,15)], nrow=84, ncol=4, byrow=TRUE),
matrix(data=waifw[c(4,8,12,16)], nrow=1201, ncol=4, byrow=TRUE)
)
}
GetWAIFWmatrix<-function(path, region) {
setwd(path)
waifwfile<-GetFilename(path, "WAIFW_both.csv")
if (is.character(waifwfile)==FALSE) {
stop(mymsg)
print("File [waifw_both.csv] is packaged with the R scripts and should be in the same directory.")
}
waifwin<-read.csv(waifwfile, stringsAsFactors = FALSE)  #vector
Rwaifw<-waifwin[waifwin$region==region & waifwin$season=='rainy', 4]
Dwaifw<-waifwin[waifwin$region==region & waifwin$season=='dry', 4]
# wboth<-array(c(expandWaifw(waifw=Rwaifw), expandWaifw(waifw=Dwaifw)), dim=c(361,4,2))
# Chloe edit 3/29: Need to change dims to suit larger matrix.
wboth<-array(c(expandWaifw(waifw=Rwaifw), expandWaifw(waifw=Dwaifw)), dim=c(1441,4,2))
dimnames(wboth)[[3]]<-c("rainy", "dry")
return(wboth)
}
#WAIFW matrix setup
wboth<-GetWAIFWmatrix(path=script.dir, region=myregion)
if (!(is.numeric(wboth))) {
stop(waifwerr)
}
#initialize population
startSize <- myparams[myparams$year==year(start)-1, "totalpop"]
initpop<-InitializePopulation(scriptdir=script.dir, inputdir=inputdir, start=start, end=end, popsize=startSize, country=mycountry, region=myregion)
#check for errors
if (!(is.numeric(initpop))) {
if (disterr!="") { print(disterr) }
if (dxerr!="") { print(dxerr) }
stop(initmsg)
}
#begin simulations
my_data <- list()
WAIFWmx=wboth
dim(WAIFWmx)
